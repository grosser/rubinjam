#!/usr/bin/env ruby
# generated by rubinjam v0.5.1 -- https://github.com/grosser/rubinjam
module Rubinjam
  LIBRARIES = {
    "rubinjam/internal" => "module Rubinjam\n  ROOT = File.expand_path(\"../\", __FILE__) << \"/rubinjam/\"\n\n  class << self\n    def normalize_file(file)\n      return file unless file.start_with?(\"/\")\n      if file.start_with?(ROOT)\n        file.sub(ROOT, \"\")\n      else\n        file.split('/lib/').last\n      end\n    end\n\n    def file_from_nesting(mod, const)\n      if file = mod.rubinjam_autload[const]\n        return [mod, file]\n      end\n\n      nesting(mod.name)[1..-1].detect do |mod|\n        file = mod.rubinjam_autload[const]\n        break [mod, file] if file\n      end\n    end\n\n    # this does not reflect the actual Module.nesting of the caller,\n    # but it should be close enough\n    def nesting(name)\n      nesting = []\n      namespace = name.split(\"::\")\n      namespace.inject(Object) do |base, n|\n        klass = base.const_get(n)\n        nesting << klass\n        klass\n      end\n      nesting.reverse\n    end\n  end\n\n  module ModuleAutoloadFix\n    def self.included(base)\n      base.class_eval do\n        def rubinjam_autload\n          @rubinjam_autload ||= {}\n        end\n\n        alias autoload_without_rubinjam autoload\n        def autoload(const, file)\n          normalized_file = Rubinjam.normalize_file(file)\n          if Rubinjam::LIBRARIES[normalized_file]\n            rubinjam_autload[const] = normalized_file\n          else\n            autoload_without_rubinjam(const, file)\n          end\n        end\n\n        alias const_missing_without_rubinjam const_missing\n        def const_missing(const)\n          # do not load twice / go into infitire loops\n          @rubinjam_tried_const_missing ||= {}\n          if @rubinjam_tried_const_missing[const]\n            return const_missing_without_rubinjam(const)\n          end\n          @rubinjam_tried_const_missing[const] = true\n\n          # try to find autoload in current module or nesting\n          nesting, file = Rubinjam.file_from_nesting(self, const)\n          if file\n            require file\n            nesting.const_get(const)\n          else\n            const_missing_without_rubinjam(const)\n          end\n        end\n      end\n    end\n  end\n\n  module BaseAutoloadFix\n    def self.included(base)\n      base.class_eval do\n        alias autoload_without_rubinjam autoload\n\n        def autoload(const, file)\n          normalized_file = Rubinjam.normalize_file(file)\n          if Rubinjam::LIBRARIES[normalized_file]\n            require normalized_file\n          else\n            autoload_without_rubinjam(const, file)\n          end\n        end\n      end\n    end\n  end\nend\n\nModule.send(:include, Rubinjam::ModuleAutoloadFix)\ninclude Rubinjam::BaseAutoloadFix\n\ndef require(file)\n  normalized_file = Rubinjam.normalize_file(file)\n  if code = Rubinjam::LIBRARIES[normalized_file]\n    return if code == :loaded\n    eval(code, TOPLEVEL_BINDING, \"rubinjam/\#{normalized_file}.rb\")\n    Rubinjam::LIBRARIES[normalized_file] = :loaded\n  else\n    super\n  end\nend\n",
    "rubinjam/version" => "module Rubinjam\n  VERSION = \"0.5.1\"\nend\n",
    "rubinjam" => "require \"tmpdir\"\nrequire \"bundler\"\nrequire \"rubinjam/version\"\n\nmodule Rubinjam\n  HEADER = '#!/usr/bin/env ruby'.freeze\n\n  class << self\n    # pack a directory\n    def pack(dir)\n      Dir.chdir(dir) do\n        binaries = Dir[\"bin/*\"]\n        raise \"No binary found in ./bin\" if binaries.size == 0\n        raise \"Can only pack exactly 1 binary, found \#{binaries.join(\",\")} in ./bin\" unless binaries.size == 1\n        content = environment + File.read(binaries.first)\n        [File.basename(binaries.first), content]\n      end\n    end\n\n    # pack a gem\n    def pack_gem(gem, version=nil)\n      require \"shellwords\"\n      require \"rubygems/package\"\n\n      Dir.mktmpdir do |dir|\n        Dir.chdir(dir) do\n          # fetch\n          command = \"gem fetch \#{Shellwords.escape(gem)}\"\n          command << \" -v\" << Shellwords.escape(version) if version\n          sh(command)\n\n          # load spec\n          gem_ball = Dir[\"*.gem\"].first\n          spec = Gem::Package.new(gem_ball).spec.to_ruby\n          sh(\"gem unpack \#{Shellwords.escape(gem_ball)}\")\n\n          # bundle\n          Dir.chdir(gem_ball.sub(\".gem\", \"\")) do\n            File.open(\"\#{gem}.gemspec\", \"w\") { |f| f.write spec }\n            Rubinjam.pack(Dir.pwd)\n          end\n        end\n      end\n    end\n\n    private\n\n    def libraries\n      libs_from_paths([\"lib\"]).\n        merge!(gem_libraries).\n        merge!(\"rubinjam/internal\" => internal_code)\n    end\n\n    def internal_code\n      if defined?(LIBRARIES)\n        LIBRARIES[\"rubinjam/internal\"] # dogfooding ourself -> cannot reed files\n      else\n        File.read(File.expand_path(\"../rubinjam/internal.rb\", __FILE__))\n      end\n    end\n\n    # unpack dependent gems with bundler so we can pack them\n    # this takes a while so we try to avoid if possible\n    def gem_libraries\n      return {} unless gemspec = Dir[\"*.gemspec\"].first\n      return {} unless File.read(gemspec) =~ /add_(runtime_)?dependency/\n\n      Dir.mktmpdir do |dir|\n        sh \"cp -R . \#{dir}/\"\n        Dir.chdir(dir) do\n          write gemspec, File.read(gemspec).gsub(/.*add_development_dependency.*/, \"\")\n          write \"Gemfile\", <<-RUBY.gsub(/^            /, \"\")\n            source \"https://rubygems.org\"\n            gemspec\n          RUBY\n\n          sh(\"rm -f Gemfile.lock\")\n          sh(\"BUNDLE_IGNORE_CONFIG=1 bundle install --quiet --path bundle\") # heroku has a --deployment config -> ignore it\n          paths = sh(\"bundle exec ruby -e 'puts $LOAD_PATH'\").split(\"\\n\")\n          paths = paths.grep(%r{/gems/}).reject { |r| r =~ %r{/gems/bundler-\\d} }\n          libs_from_paths(paths)\n        end\n      end\n    end\n\n    def libs_from_paths(paths)\n      paths.select { |p| File.directory?(p) }.inject({}) do |all, path|\n        Dir.chdir path do\n          all.merge!(Hash[Dir[\"**/*.rb\"].map { |f| [f.sub(/\\.rb$/, \"\"), File.read(f)] }])\n        end\n      end\n    end\n\n    def sh(command, options={})\n      result = Bundler.with_clean_env { `\#{command} 2>/dev/null` }\n      raise \"\#{options[:fail] ? \"SUCCESS\" : \"FAIL\"} \#{command}\\n\#{result}\" if $?.success? == !!options[:fail]\n      result\n    end\n\n    def write(file, content)\n      FileUtils.mkdir_p(File.dirname(file))\n      File.open(file, \"w\") { |f| f.write content }\n    end\n\n    def environment\n      <<-RUBY.gsub(/^        /, \"\")\n        \#{HEADER}\n        # generated by rubinjam v\#{VERSION} -- https://github.com/grosser/rubinjam\n        module Rubinjam\n          LIBRARIES = {\n            \#{libraries.map { |name,content| \"\#{name.inspect} => \#{content.inspect}\" }.join(\",\\n    \")}\n          }\n        end\n        eval(Rubinjam::LIBRARIES.fetch(\"rubinjam/internal\"), TOPLEVEL_BINDING, \"rubinjam\")\n      RUBY\n    end\n  end\nend\n"
  }
end
eval(Rubinjam::LIBRARIES.fetch("rubinjam/internal"), TOPLEVEL_BINDING, "rubinjam")
#!/usr/bin/env ruby
require 'optparse'

$LOAD_PATH << File.join(File.dirname(__FILE__), '..', 'lib')
require 'rubinjam'

OptionParser.new do |opts|
  opts.banner = <<BANNER
Rubinjam

Jam a gem into a universal binary that works with any ruby

Usage:
    rubinjam # convert current directory into a binary

Options:
BANNER
  opts.on("-h", "--help","Show this.") { puts opts; exit }
  opts.on('-v', '--version','Show Version'){ require 'rubinjam/version'; puts Rubinjam::VERSION; exit}
end.parse!

name, content = Rubinjam.pack(Dir.pwd)
File.open(name, 'w') { |f| f.write content }
`chmod +x #{name}`
raise "Unable to add execution bit" unless $?.success?
