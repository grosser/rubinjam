#!/usr/bin/env ruby
# generated by rubinjam v0.7.1 -- https://github.com/grosser/rubinjam
module Rubinjam
  LIBRARIES = {
    "rubinjam/internal" => "module Rubinjam\n  ROOT = File.expand_path(\"../\", __FILE__) << \"/rubinjam/\"\n\n  class << self\n    def normalize_file(file)\n      return file unless file.start_with?(\"/\")\n      if file.start_with?(ROOT)\n        file.sub(ROOT, \"\")\n      else\n        file.split('/lib/').last\n      end\n    end\n\n    def file_from_nesting(mod, const)\n      if file = mod.rubinjam_autload[const]\n        return [mod, file]\n      end\n\n      nesting(mod.name)[1..-1].detect do |mod|\n        file = mod.rubinjam_autload[const]\n        break [mod, file] if file\n      end\n    end\n\n    # this does not reflect the actual Module.nesting of the caller,\n    # but it should be close enough\n    def nesting(name)\n      nesting = []\n      namespace = name.split(\"::\")\n      namespace.inject(Object) do |base, n|\n        klass = base.const_get(n)\n        nesting << klass\n        klass\n      end\n      nesting.reverse\n    end\n  end\n\n  module ModuleAutoloadFix\n    def self.included(base)\n      base.class_eval do\n        def rubinjam_autload\n          @rubinjam_autload ||= {}\n        end\n\n        alias autoload_without_rubinjam autoload\n        def autoload(const, file)\n          normalized_file = Rubinjam.normalize_file(file)\n          if Rubinjam::LIBRARIES[normalized_file]\n            rubinjam_autload[const] = normalized_file\n          else\n            autoload_without_rubinjam(const, file)\n          end\n        end\n\n        alias const_missing_without_rubinjam const_missing\n        def const_missing(const)\n          # do not load twice / go into infitire loops\n          @rubinjam_tried_const_missing ||= {}\n          if @rubinjam_tried_const_missing[const]\n            return const_missing_without_rubinjam(const)\n          end\n          @rubinjam_tried_const_missing[const] = true\n\n          # try to find autoload in current module or nesting\n          nesting, file = Rubinjam.file_from_nesting(self, const)\n          if file\n            require file\n            nesting.const_get(const)\n          else\n            const_missing_without_rubinjam(const)\n          end\n        end\n      end\n    end\n  end\n\n  module BaseAutoloadFix\n    def self.included(base)\n      base.class_eval do\n        alias autoload_without_rubinjam autoload\n\n        def autoload(const, file)\n          normalized_file = Rubinjam.normalize_file(file)\n          if Rubinjam::LIBRARIES[normalized_file]\n            require normalized_file\n          else\n            autoload_without_rubinjam(const, file)\n          end\n        end\n      end\n    end\n  end\nend\n\nModule.send(:include, Rubinjam::ModuleAutoloadFix)\ninclude Rubinjam::BaseAutoloadFix\n\ndef require(file)\n  normalized_file = Rubinjam.normalize_file(file)\n  if code = Rubinjam::LIBRARIES[normalized_file]\n    return if code == :loaded\n    eval(code, TOPLEVEL_BINDING, \"rubinjam/\#{normalized_file}.rb\")\n    Rubinjam::LIBRARIES[normalized_file] = :loaded\n  else\n    super\n  end\nend\n",
    "rubinjam/tasks" => "require 'rubinjam'\nrequire 'shellwords'\nrequire 'json'\n\nmodule Rubinjam\n  module Tasks\n    API_BASE =\n\n    class << self\n      def upload_binary(tag, github_token)\n        # https://github.com/foo/bar or git@github.com:foo/bar.git -> foo/bar\n        repo = sh(\"git\", \"remote\", \"get-url\", \"origin\").strip\n        repo.sub!(/\\.git$/, \"\")\n        repo = repo.split(/[:\\/]/).last(2).join(\"/\")\n\n        auth = [\"-H\", \"Authorization: token \#{github_token}\"]\n\n        id = find_or_create_release(auth, repo, tag)\n        puts \"Release \#{id}\"\n\n        # upload binary\n        begin\n          name = Rubinjam.write(Dir.pwd)\n          puts \"Uploading \#{name} release asset\"\n          sh(\n            \"curl\",\n            \"-X\", \"POST\",\n            \"--data-binary\", \"@\#{name}\",\n            \"-H\", \"Content-Type: application/octet-stream\",\n            *auth,\n            \"https://uploads.github.com/repos/\#{repo}/releases/\#{id}/assets?name=\#{name}\"\n          )\n        ensure\n          sh \"rm\", \"-f\", name.to_s\n        end\n      end\n\n      def sh(*command)\n        command = command.shelljoin\n        result = `\#{command}`\n        raise \"Command failed:\\n\#{command}\\n\#{result}\" unless $?.success?\n        result\n      end\n\n      private\n\n      def find_or_create_release(auth, repo, tag)\n        reply = sh(\"curl\", *auth, \"--data\", {tag_name: tag}.to_json, \"https://api.github.com/repos/\#{repo}/releases\")\n        unless id = JSON.parse(reply)[\"id\"]\n          reply = sh(\"curl\", *auth, \"https://api.github.com/repos/\#{repo}/releases/tags/\#{tag}\")\n          id = JSON.parse(reply).fetch(\"id\")\n        end\n        id\n      end\n    end\n  end\nend\n\nnamespace :rubinjam do\n  task :upload_binary  do\n    # find token for auth\n    github_token = begin\n      Rubinjam::Tasks.sh(\"git\", \"config\", \"github.token\").strip\n    rescue\n      abort \"Set github.token with: git config --global github.token <GITHUB-TOKEN>\"\n    end\n\n    # find current tag\n    # TODO: allow users to set TAG= or do fuzzy match ?\n    tag = Rubinjam::Tasks.sh(\"git\", \"describe\", \"--tags\", \"--exact-match\").strip\n\n    Rubinjam::Tasks.upload_binary(tag, github_token)\n  end\nend\n",
    "rubinjam/version" => "module Rubinjam\n  VERSION = \"0.7.1\"\nend\n",
    "rubinjam" => "require \"tmpdir\"\nrequire \"bundler\"\nrequire \"rubinjam/version\"\n\nmodule Rubinjam\n  HEADER = '#!/usr/bin/env ruby'.freeze\n\n  class << self\n    # pack and write a binary given a directory\n    def write(dir)\n      name, content = pack(Dir.pwd)\n      write_file name, content\n      `chmod +x \#{name}`\n      raise \"Unable to add execution bit\" unless $?.success?\n      name\n    end\n\n    # pack a directory\n    def pack(dir)\n      Dir.chdir(dir) do\n        binary = binary_path\n        content = environment + File.read(binary)\n        return [File.basename(binary), content]\n      end\n    end\n\n    # pack a gem\n    def pack_gem(gem, version=nil)\n      require \"shellwords\"\n      require \"rubygems/package\"\n\n      Dir.mktmpdir do |dir|\n        Dir.chdir(dir) do\n          # fetch\n          command = \"gem fetch \#{Shellwords.escape(gem)}\"\n          command << \" -v\" << Shellwords.escape(version) if version\n          sh(command)\n\n          # load spec\n          gem_ball = Dir[\"*.gem\"].first\n          spec = Gem::Package.new(gem_ball).spec.to_ruby\n          sh(\"gem unpack \#{Shellwords.escape(gem_ball)}\")\n\n          # bundle\n          Dir.chdir(gem_ball.sub(\".gem\", \"\")) do\n            write_file \"\#{gem}.gemspec\", spec\n            Rubinjam.pack(Dir.pwd)\n          end\n        end\n      end\n    end\n\n    private\n\n    def binary_path\n      folders = [\"./exe\", \"./bin\"]\n      folders.each do |folder|\n        binaries = Dir[\"\#{folder}/*\"]\n        next if binaries.size == 0\n        if binaries.size != 1\n          local = File.join(folder, File.basename(Dir.pwd))\n          if binaries.include?(local)\n            binaries = [local]\n          else\n            raise \"Can only pack exactly 1 binary, found \#{binaries.join(\", \")} in \#{folder}\"\n          end\n        end\n        return binaries.first\n      end\n      raise \"No binary found in \#{folders.join(\" or \")}\"\n    end\n\n    def libraries\n      libs_from_paths([\"lib\"]).\n        merge!(gem_libraries).\n        merge!(\"rubinjam/internal\" => internal_code)\n    end\n\n    def internal_code\n      if defined?(LIBRARIES)\n        LIBRARIES[\"rubinjam/internal\"] # dogfooding ourself -> cannot reed files\n      else\n        File.read(File.expand_path(\"../rubinjam/internal.rb\", __FILE__))\n      end\n    end\n\n    # unpack dependent gems with bundler so we can pack them\n    # this takes a while so we try to avoid if possible\n    def gem_libraries\n      return {} unless gemspec = Dir[\"*.gemspec\"].first\n\n      dependency = \"add_(runtime_)?dependency\"\n      content = File.read(gemspec)\n      content.gsub!(/.*\#{dependency}.*['\"\\{\\<]json['\">\\}].*/, '')\n      content.gsub!(/.*add_development_dependency.*/, \"\")\n      return {} unless content =~ /\#{dependency}/\n\n      Dir.mktmpdir do |dir|\n        sh \"cp -R . \#{dir}/\"\n        Dir.chdir(dir) do\n          write_file gemspec, content\n          write_file \"Gemfile\", <<-RUBY.gsub(/^            /, \"\")\n            source \"https://rubygems.org\"\n            gemspec\n          RUBY\n\n          sh(\"rm -f Gemfile.lock\")\n          sh(\"BUNDLE_IGNORE_CONFIG=1 bundle install --quiet --path bundle\") # heroku has a --deployment config -> ignore it\n          paths = sh(\"bundle exec ruby -e 'puts $LOAD_PATH'\").split(\"\\n\")\n          paths = paths.grep(%r{/gems/}).reject { |r| r =~ %r{/gems/bundler-\\d} }\n          libs_from_paths(paths)\n        end\n      end\n    end\n\n    def libs_from_paths(paths)\n      paths.select { |p| File.directory?(p) }.inject({}) do |all, path|\n        Dir.chdir path do\n          all.merge!(Hash[Dir[\"**/*.rb\"].map { |f| [f.sub(/\\.rb$/, \"\"), File.read(f)] }])\n        end\n      end\n    end\n\n    def sh(command, options={})\n      result = Bundler.with_unbundled_env { `\#{command} 2>/dev/null` }\n      raise \"\#{options[:fail] ? \"SUCCESS\" : \"FAIL\"} \#{command}\\n\#{result}\" if $?.success? == !!options[:fail]\n      result\n    end\n\n    def write_file(file, content)\n      FileUtils.mkdir_p(File.dirname(file))\n      File.open(file, \"w\") { |f| f.write content }\n    end\n\n    def environment\n      <<-RUBY.gsub(/^        /, \"\")\n        \#{HEADER}\n        # generated by rubinjam v\#{VERSION} -- https://github.com/grosser/rubinjam\n        module Rubinjam\n          LIBRARIES = {\n            \#{libraries.map { |name,content| \"\#{name.inspect} => \#{content.inspect}\" }.join(\",\\n    \")}\n          }\n        end\n        eval(Rubinjam::LIBRARIES.fetch(\"rubinjam/internal\"), TOPLEVEL_BINDING, \"rubinjam\")\n      RUBY\n    end\n  end\nend\n"
  }
end
eval(Rubinjam::LIBRARIES.fetch("rubinjam/internal"), TOPLEVEL_BINDING, "rubinjam")
#!/usr/bin/env ruby
require 'optparse'

$LOAD_PATH << File.join(File.dirname(__FILE__), '..', 'lib')
require 'rubinjam'

OptionParser.new do |opts|
  opts.banner = <<BANNER
Rubinjam

Jam a gem into a universal binary that works with any ruby

Usage:
    rubinjam # convert current directory into a binary

Options:
BANNER
  opts.on("-h", "--help","Show this.") { puts opts; exit }
  opts.on('-v', '--version','Show Version'){ require 'rubinjam/version'; puts Rubinjam::VERSION; exit}
end.parse!

Rubinjam.write(Dir.pwd)
