#!/usr/bin/env ruby
# generated by rubinjam v0.4.0 -- https://github.com/grosser/rubinjam
module Rubinjam
  LIBRARIES = {
    "rubinjam/version" => "module Rubinjam\n  VERSION = \"0.4.0\"\nend\n",
    "rubinjam" => "require \"tmpdir\"\nrequire \"bundler\"\nrequire \"rubinjam/version\"\n\nmodule Rubinjam\n  HEADER = '#!/usr/bin/env ruby'.freeze\n\n  class << self\n    def pack(dir)\n      Dir.chdir(dir) do\n        binaries = Dir[\"bin/*\"]\n        raise \"No binary found in ./bin\" if binaries.size == 0\n        raise \"Can only pack exactly 1 binary, found \#{binaries.join(\",\")} in ./bin\" unless binaries.size == 1\n        content = environment + File.read(binaries.first)\n        [File.basename(binaries.first), content]\n      end\n    end\n\n    def pack_gem(gem, version=nil)\n      require \"shellwords\"\n      require \"rubygems/package\"\n\n      Dir.mktmpdir do |dir|\n        Dir.chdir(dir) do\n          # fetch\n          command = \"gem fetch \#{Shellwords.escape(gem)}\"\n          command << \" -v\" << version if version\n          sh(command)\n\n          # load spec\n          gem_ball = Dir[\"*.gem\"].first\n          spec = Gem::Package.new(gem_ball).spec.to_ruby\n          sh(\"gem unpack \#{gem_ball}\")\n\n          # bundle\n          Dir.chdir(gem_ball.sub(\".gem\", \"\")) do\n            File.open(\"\#{gem}.gemspec\", \"w\") { |f| f.write spec }\n            Rubinjam.pack(Dir.pwd)\n          end\n        end\n      end\n    end\n\n    private\n\n    def libraries\n      libs_from_paths([\"lib\"]).merge(gem_libraries)\n    end\n\n    def gem_libraries\n      return {} unless gemspec = Dir[\"*.gemspec\"].first\n      return {} unless File.read(gemspec) =~ /add_(runtime_)?dependency/\n\n      Dir.mktmpdir do |dir|\n        sh \"cp -R . \#{dir}/\"\n        Dir.chdir(dir) do\n          write gemspec, File.read(gemspec).gsub(/.*add_development_dependency.*/, \"\")\n          write \"Gemfile\", <<-RUBY.gsub(/^            /, \"\")\n            source \"https://rubygems.org\"\n            gemspec\n          RUBY\n\n          sh(\"rm -f Gemfile.lock\")\n          sh(\"BUNDLE_IGNORE_CONFIG=1 bundle install --quiet --path bundle\") # heroku has a --deployment config -> ignore it\n          paths = sh(\"bundle exec ruby -e 'puts $LOAD_PATH'\").split(\"\\n\")\n          paths = paths.grep(%r{/gems/}).reject { |r| r =~ %r{/gems/bundler-\\d} }\n          libs_from_paths(paths)\n        end\n      end\n    end\n\n    def libs_from_paths(paths)\n      paths.select { |p| File.directory?(p) }.inject({}) do |all, path|\n        Dir.chdir path do\n          all.merge!(Hash[Dir[\"**/*.rb\"].map { |f| [f.sub(/\\.rb$/, \"\"), File.read(f)] }])\n        end\n      end\n    end\n\n    def sh(command, options={})\n      result = Bundler.with_clean_env { `\#{command} 2>/dev/null` }\n      raise \"\#{options[:fail] ? \"SUCCESS\" : \"FAIL\"} \#{command}\\n\#{result}\" if $?.success? == !!options[:fail]\n      result\n    end\n\n    def write(file, content)\n      FileUtils.mkdir_p(File.dirname(file))\n      File.open(file, \"w\") { |f| f.write content }\n    end\n\n    def environment\n      <<-RUBY.gsub(/^        /, \"\")\n        \#{HEADER}\n        # generated by rubinjam v\#{VERSION} -- https://github.com/grosser/rubinjam\n        module Rubinjam\n          LIBRARIES = {\n            \#{libraries.map { |name,content| \"\#{name.inspect} => \#{content.inspect}\" }.join(\",\\n    \")}\n          }\n\n          ROOT = File.expand_path(\"../\", __FILE__) << \"/rubinjam/\"\n\n          class << self\n            def normalize_file(file)\n              return file unless file.start_with?(\"/\")\n              if file.start_with?(ROOT)\n                file.sub(ROOT, \"\")\n              else\n                file.split('/lib/').last\n              end\n            end\n\n            def file_from_nesting(mod, const)\n              if file = mod.rubinjam_autload[const]\n                return [mod, file]\n              end\n\n              nesting(mod.name)[1..-1].detect do |mod|\n                file = mod.rubinjam_autload[const]\n                break [mod, file] if file\n              end\n            end\n\n            # this does not reflect the actual Module.nesting of the caller,\n            # but it should be close enough\n            def nesting(name)\n              nesting = []\n              namespace = name.split(\"::\")\n              namespace.inject(Object) do |base, n|\n                klass = base.const_get(n)\n                nesting << klass\n                klass\n              end\n              nesting.reverse\n            end\n          end\n\n          module ModuleAutoloadFix\n            def self.included(base)\n              base.class_eval do\n                def rubinjam_autload\n                  @rubinjam_autload ||= {}\n                end\n\n                alias autoload_without_rubinjam autoload\n                def autoload(const, file)\n                  normalized_file = Rubinjam.normalize_file(file)\n                  if Rubinjam::LIBRARIES[normalized_file]\n                    rubinjam_autload[const] = normalized_file\n                  else\n                    autoload_without_rubinjam(const, file)\n                  end\n                end\n\n                alias const_missing_without_rubinjam const_missing\n                def const_missing(const)\n                  # do not load twice / go into infitire loops\n                  @rubinjam_tried_const_missing ||= {}\n                  if @rubinjam_tried_const_missing[const]\n                    return const_missing_without_rubinjam(const)\n                  end\n                  @rubinjam_tried_const_missing[const] = true\n\n                  # try to find autoload in current module or nesting\n                  nesting, file = Rubinjam.file_from_nesting(self, const)\n                  if file\n                    require file\n                    nesting.const_get(const)\n                  else\n                    const_missing_without_rubinjam(const)\n                  end\n                end\n              end\n            end\n          end\n\n          module BaseAutoloadFix\n            def self.included(base)\n              base.class_eval do\n                alias autoload_without_rubinjam autoload\n\n                def autoload(const, file)\n                  normalized_file = Rubinjam.normalize_file(file)\n                  if Rubinjam::LIBRARIES[normalized_file]\n                    require normalized_file\n                  else\n                    autoload_without_rubinjam(const, file)\n                  end\n                end\n              end\n            end\n          end\n        end\n\n        Module.send(:include, Rubinjam::ModuleAutoloadFix)\n        include Rubinjam::BaseAutoloadFix\n\n        def require(file)\n          normalized_file = Rubinjam.normalize_file(file)\n          if code = Rubinjam::LIBRARIES[normalized_file]\n            return if code == :loaded\n            eval(code, TOPLEVEL_BINDING, \"rubinjam/\\\#{normalized_file}.rb\")\n            Rubinjam::LIBRARIES[normalized_file] = :loaded\n          else\n            super\n          end\n        end\n      RUBY\n    end\n  end\nend\n"
  }

  ROOT = File.expand_path("../", __FILE__) << "/rubinjam/"

  class << self
    def normalize_file(file)
      return file unless file.start_with?("/")
      if file.start_with?(ROOT)
        file.sub(ROOT, "")
      else
        file.split('/lib/').last
      end
    end

    def file_from_nesting(mod, const)
      if file = mod.rubinjam_autload[const]
        return [mod, file]
      end

      nesting(mod.name)[1..-1].detect do |mod|
        file = mod.rubinjam_autload[const]
        break [mod, file] if file
      end
    end

    # this does not reflect the actual Module.nesting of the caller,
    # but it should be close enough
    def nesting(name)
      nesting = []
      namespace = name.split("::")
      namespace.inject(Object) do |base, n|
        klass = base.const_get(n)
        nesting << klass
        klass
      end
      nesting.reverse
    end
  end

  module ModuleAutoloadFix
    def self.included(base)
      base.class_eval do
        def rubinjam_autload
          @rubinjam_autload ||= {}
        end

        alias autoload_without_rubinjam autoload
        def autoload(const, file)
          normalized_file = Rubinjam.normalize_file(file)
          if Rubinjam::LIBRARIES[normalized_file]
            rubinjam_autload[const] = normalized_file
          else
            autoload_without_rubinjam(const, file)
          end
        end

        alias const_missing_without_rubinjam const_missing
        def const_missing(const)
          # do not load twice / go into infitire loops
          @rubinjam_tried_const_missing ||= {}
          if @rubinjam_tried_const_missing[const]
            return const_missing_without_rubinjam(const)
          end
          @rubinjam_tried_const_missing[const] = true

          # try to find autoload in current module or nesting
          nesting, file = Rubinjam.file_from_nesting(self, const)
          if file
            require file
            nesting.const_get(const)
          else
            const_missing_without_rubinjam(const)
          end
        end
      end
    end
  end

  module BaseAutoloadFix
    def self.included(base)
      base.class_eval do
        alias autoload_without_rubinjam autoload

        def autoload(const, file)
          normalized_file = Rubinjam.normalize_file(file)
          if Rubinjam::LIBRARIES[normalized_file]
            require normalized_file
          else
            autoload_without_rubinjam(const, file)
          end
        end
      end
    end
  end
end

Module.send(:include, Rubinjam::ModuleAutoloadFix)
include Rubinjam::BaseAutoloadFix

def require(file)
  normalized_file = Rubinjam.normalize_file(file)
  if code = Rubinjam::LIBRARIES[normalized_file]
    return if code == :loaded
    eval(code, TOPLEVEL_BINDING, "rubinjam/#{normalized_file}.rb")
    Rubinjam::LIBRARIES[normalized_file] = :loaded
  else
    super
  end
end
#!/usr/bin/env ruby
require 'optparse'

$LOAD_PATH << File.join(File.dirname(__FILE__), '..', 'lib')
require 'rubinjam'

OptionParser.new do |opts|
  opts.banner = <<BANNER
Rubinjam

Jam a gem into a universal binary that works with any ruby

Usage:
    rubinjam # convert current directory into a binary

Options:
BANNER
  opts.on("-h", "--help","Show this.") { puts opts; exit }
  opts.on('-v', '--version','Show Version'){ require 'rubinjam/version'; puts Rubinjam::VERSION; exit}
end.parse!

name, content = Rubinjam.pack(Dir.pwd)
File.open(name, 'w') { |f| f.write content }
`chmod +x #{name}`
raise "Unable to add execution bit" unless $?.success?
