#!/usr/bin/env ruby
# generated by rubinjam v0.7.1 -- https://github.com/grosser/rubinjam
module Rubinjam
  LIBRARIES = {
    "rubinjam" => "require \"tmpdir\"\nrequire \"bundler\"\nrequire \"rubinjam/version\"\n\nmodule Rubinjam\n  HEADER = '#!/usr/bin/env ruby'.freeze\n\n  class << self\n    # pack and write a binary given a directory\n    def write(dir)\n      name, content = pack(Dir.pwd)\n      write_file name, content\n      `chmod +x \#{name}`\n      raise \"Unable to add execution bit\" unless $?.success?\n      name\n    end\n\n    # pack a directory\n    def pack(dir)\n      Dir.chdir(dir) do\n        binary = binary_path\n        content = environment + File.read(binary)\n        return [File.basename(binary), content]\n      end\n    end\n\n    # pack a gem\n    def pack_gem(gem, version=nil)\n      require \"shellwords\"\n      require \"rubygems/package\"\n\n      Dir.mktmpdir do |dir|\n        Dir.chdir(dir) do\n          # fetch\n          command = \"gem fetch \#{Shellwords.escape(gem)}\"\n          command << \" -v\" << Shellwords.escape(version) if version\n          sh(command)\n\n          # load spec\n          gem_ball = Dir[\"*.gem\"].first\n          spec = Gem::Package.new(gem_ball).spec.to_ruby\n          sh(\"gem unpack \#{Shellwords.escape(gem_ball)}\")\n\n          # bundle\n          Dir.chdir(gem_ball.sub(\".gem\", \"\")) do\n            write_file \"\#{gem}.gemspec\", spec\n            Rubinjam.pack(Dir.pwd)\n          end\n        end\n      end\n    end\n\n    private\n\n    def binary_path\n      folders = [\"./exe\", \"./bin\"]\n      folders.each do |folder|\n        binaries = Dir[\"\#{folder}/*\"]\n        next if binaries.size == 0\n        if binaries.size != 1\n          local = File.join(folder, File.basename(Dir.pwd))\n          if binaries.include?(local)\n            binaries = [local]\n          else\n            raise \"Can only pack exactly 1 binary, found \#{binaries.join(\", \")} in \#{folder}\"\n          end\n        end\n        return binaries.first\n      end\n      raise \"No binary found in \#{folders.join(\" or \")}\"\n    end\n\n    def libraries\n      libs_from_paths([\"lib\"]).\n        merge!(gem_libraries).\n        merge!(\"rubinjam/internal\" => internal_code)\n    end\n\n    def internal_code\n      if defined?(LIBRARIES)\n        LIBRARIES[\"rubinjam/internal\"] # dogfooding ourself -> cannot reed files\n      else\n        File.read(File.expand_path(\"../rubinjam/internal.rb\", __FILE__))\n      end\n    end\n\n    # unpack dependent gems with bundler so we can pack them\n    # this takes a while so we try to avoid if possible\n    def gem_libraries\n      return {} unless gemspec = Dir[\"*.gemspec\"].first\n\n      dependency = \"add_(runtime_)?dependency\"\n      content = File.read(gemspec)\n      content.gsub!(/.*\#{dependency}.*['\"\\{\\<]json['\">\\}].*/, '')\n      content.gsub!(/.*add_development_dependency.*/, \"\")\n      return {} unless content =~ /\#{dependency}/\n\n      Dir.mktmpdir do |dir|\n        sh \"cp -R . \#{dir}/\"\n        Dir.chdir(dir) do\n          write_file gemspec, content\n          write_file \"Gemfile\", <<-RUBY.gsub(/^            /, \"\")\n            source \"https://rubygems.org\"\n            gemspec\n          RUBY\n\n          sh(\"rm -f Gemfile.lock\")\n          sh(\"BUNDLE_IGNORE_CONFIG=1 bundle install --quiet --path bundle\") # heroku has a --deployment config -> ignore it\n          paths = sh(\"bundle exec ruby -e 'puts $LOAD_PATH'\").split(\"\\n\")\n          paths = paths.grep(%r{/gems/}).reject { |r| r =~ %r{/gems/bundler-\\d} }\n          libs_from_paths(paths)\n        end\n      end\n    end\n\n    def libs_from_paths(paths)\n      paths.select { |p| File.directory?(p) }.inject({}) do |all, path|\n        Dir.chdir path do\n          all.merge!(Hash[Dir[\"**/*.rb\"].map { |f| [f.sub(/\\.rb$/, \"\"), File.read(f)] }])\n        end\n      end\n    end\n\n    def sh(command, options={})\n      result = Bundler.with_clean_env { `\#{command} 2>/dev/null` }\n      raise \"\#{options[:fail] ? \"SUCCESS\" : \"FAIL\"} \#{command}\\n\#{result}\" if $?.success? == !!options[:fail]\n      result\n    end\n\n    def write_file(file, content)\n      FileUtils.mkdir_p(File.dirname(file))\n      File.open(file, \"w\") { |f| f.write content }\n    end\n\n    def environment\n      <<-RUBY.gsub(/^        /, \"\")\n        \#{HEADER}\n        # generated by rubinjam v\#{VERSION} -- https://github.com/grosser/rubinjam\n        module Rubinjam\n          LIBRARIES = {\n            \#{libraries.map { |name,content| \"\#{name.inspect} => \#{content.inspect}\" }.join(\",\\n    \")}\n          }\n        end\n        eval(Rubinjam::LIBRARIES.fetch(\"rubinjam/internal\"), TOPLEVEL_BINDING, \"rubinjam\")\n      RUBY\n    end\n  end\nend\n",
    "rubinjam/version" => "module Rubinjam\n  VERSION = \"0.7.1\"\nend\n",
    "rubinjam/tasks" => "require 'rubinjam'\nrequire 'shellwords'\nrequire 'json'\n\nmodule Rubinjam\n  module Tasks\n    API_BASE =\n\n    class << self\n      def upload_binary(tag, github_token)\n        # https://github.com/foo/bar or git@github.com:foo/bar.git -> foo/bar\n        repo = sh(\"git\", \"remote\", \"get-url\", \"origin\").strip\n        repo.sub!(/\\.git$/, \"\")\n        repo = repo.split(/[:\\/]/).last(2).join(\"/\")\n\n        auth = [\"-H\", \"Authorization: token \#{github_token}\"]\n\n        id = find_or_create_release(auth, repo, tag)\n        puts \"Release \#{id}\"\n\n        # upload binary\n        begin\n          name = Rubinjam.write(Dir.pwd)\n          puts \"Uploading \#{name} release asset\"\n          sh(\n            \"curl\",\n            \"-X\", \"POST\",\n            \"--data-binary\", \"@\#{name}\",\n            \"-H\", \"Content-Type: application/octet-stream\",\n            *auth,\n            \"https://uploads.github.com/repos/\#{repo}/releases/\#{id}/assets?name=\#{name}\"\n          )\n        ensure\n          sh \"rm\", \"-f\", name.to_s\n        end\n      end\n\n      def sh(*command)\n        command = command.shelljoin\n        result = `\#{command}`\n        raise \"Command failed:\\n\#{command}\\n\#{result}\" unless $?.success?\n        result\n      end\n\n      private\n\n      def find_or_create_release(auth, repo, tag)\n        reply = sh(\"curl\", *auth, \"--data\", {tag_name: tag}.to_json, \"https://api.github.com/repos/\#{repo}/releases\")\n        unless id = JSON.parse(reply)[\"id\"]\n          reply = sh(\"curl\", *auth, \"https://api.github.com/repos/\#{repo}/releases/tags/\#{tag}\")\n          id = JSON.parse(reply).fetch(\"id\")\n        end\n        id\n      end\n    end\n  end\nend\n\nnamespace :rubinjam do\n  task :upload_binary  do\n    # find token for auth\n    github_token = begin\n      Rubinjam::Tasks.sh(\"git\", \"config\", \"github.token\").strip\n    rescue\n      abort \"Set github.token with: git config --global github.token <GITHUB-TOKEN>\"\n    end\n\n    # find current tag\n    # TODO: allow users to set TAG= or do fuzzy match ?\n    tag = Rubinjam::Tasks.sh(\"git\", \"describe\", \"--tags\", \"--exact-match\").strip\n\n    Rubinjam::Tasks.upload_binary(tag, github_token)\n  end\nend\n",
    "rubinjam/internal" => "module Rubinjam\n  ROOT = File.expand_path(\"../\", __FILE__) << \"/rubinjam/\"\n\n  class << self\n    def normalize_file(file)\n      return file unless file.start_with?(\"/\")\n      if file.start_with?(ROOT)\n        file.sub(ROOT, \"\")\n      else\n        file.split('/lib/').last\n      end\n    end\n\n    def file_from_nesting(mod, const)\n      if file = mod.rubinjam_autload[const]\n        return [mod, file]\n      end\n\n      nesting(mod.name)[1..-1].detect do |mod|\n        file = mod.rubinjam_autload[const]\n        break [mod, file] if file\n      end\n    end\n\n    # this does not reflect the actual Module.nesting of the caller,\n    # but it should be close enough\n    def nesting(name)\n      nesting = []\n      namespace = name.split(\"::\")\n      namespace.inject(Object) do |base, n|\n        klass = base.const_get(n)\n        nesting << klass\n        klass\n      end\n      nesting.reverse\n    end\n  end\n\n  module ModuleAutoloadFix\n    def self.included(base)\n      base.class_eval do\n        def rubinjam_autload\n          @rubinjam_autload ||= {}\n        end\n\n        alias autoload_without_rubinjam autoload\n        def autoload(const, file)\n          normalized_file = Rubinjam.normalize_file(file)\n          if Rubinjam::LIBRARIES[normalized_file]\n            rubinjam_autload[const] = normalized_file\n          else\n            autoload_without_rubinjam(const, file)\n          end\n        end\n\n        alias const_missing_without_rubinjam const_missing\n        def const_missing(const)\n          # do not load twice / go into infitire loops\n          @rubinjam_tried_const_missing ||= {}\n          if @rubinjam_tried_const_missing[const]\n            return const_missing_without_rubinjam(const)\n          end\n          @rubinjam_tried_const_missing[const] = true\n\n          # try to find autoload in current module or nesting\n          nesting, file = Rubinjam.file_from_nesting(self, const)\n          if file\n            require file\n            nesting.const_get(const)\n          else\n            const_missing_without_rubinjam(const)\n          end\n        end\n      end\n    end\n  end\n\n  module BaseAutoloadFix\n    def self.included(base)\n      base.class_eval do\n        alias autoload_without_rubinjam autoload\n\n        def autoload(const, file)\n          normalized_file = Rubinjam.normalize_file(file)\n          if Rubinjam::LIBRARIES[normalized_file]\n            require normalized_file\n          else\n            autoload_without_rubinjam(const, file)\n          end\n        end\n      end\n    end\n  end\nend\n\nModule.send(:include, Rubinjam::ModuleAutoloadFix)\ninclude Rubinjam::BaseAutoloadFix\n\ndef require(file)\n  normalized_file = Rubinjam.normalize_file(file)\n  if code = Rubinjam::LIBRARIES[normalized_file]\n    return if code == :loaded\n    eval(code, TOPLEVEL_BINDING, \"rubinjam/\#{normalized_file}.rb\")\n    Rubinjam::LIBRARIES[normalized_file] = :loaded\n  else\n    super\n  end\nend\n",
    "did_you_mean/experimental/initializer_name_correction" => "# frozen-string-literal: true\n\nrequire 'did_you_mean/levenshtein'\n\nmodule DidYouMean\n  module Experimental\n    module InitializerNameCorrection\n      def method_added(name)\n        super\n\n        distance = Levenshtein.distance(name.to_s, 'initialize')\n        if distance != 0 && distance <= 2\n          warn \"warning: \#{name} might be misspelled, perhaps you meant initialize?\"\n        end\n      end\n    end\n\n    ::Class.prepend(InitializerNameCorrection)\n  end\nend\n",
    "did_you_mean/experimental/ivar_name_correction" => "# frozen-string-literal: true\n\nrequire 'did_you_mean'\n\nmodule DidYouMean\n  module Experimental #:nodoc:\n    class IvarNameCheckerBuilder #:nodoc:\n      attr_reader :original_checker\n\n      def initialize(original_checker) #:nodoc:\n        @original_checker = original_checker\n      end\n\n      def new(no_method_error) #:nodoc:\n        IvarNameChecker.new(no_method_error, original_checker: @original_checker)\n      end\n    end\n\n    class IvarNameChecker #:nodoc:\n      REPLS = {\n        \"(irb)\" => -> { Readline::HISTORY.to_a.last }\n      }\n\n      TRACE = TracePoint.trace(:raise) do |tp|\n        e = tp.raised_exception\n\n        if SPELL_CHECKERS.include?(e.class.to_s) && !e.instance_variable_defined?(:@frame_binding)\n          e.instance_variable_set(:@frame_binding, tp.binding)\n        end\n      end\n\n      attr_reader :original_checker\n\n      def initialize(no_method_error, original_checker: )\n        @original_checker = original_checker.new(no_method_error)\n\n        @location   = no_method_error.backtrace_locations.first\n        @ivar_names = no_method_error.frame_binding.receiver.instance_variables\n      end\n\n      def corrections\n        original_checker.corrections + ivar_name_corrections\n      end\n\n      def ivar_name_corrections\n        @ivar_name_corrections ||= SpellChecker.new(dictionary: @ivar_names).correct(receiver_name.to_s)\n      end\n\n      private\n\n      def receiver_name\n        return unless @original_checker.receiver.nil?\n\n        abs_path = @location.absolute_path\n        lineno   = @location.lineno\n\n        /@(\\w+)*\\.\#{@original_checker.method_name}/ =~ line(abs_path, lineno).to_s && $1\n      end\n\n      def line(abs_path, lineno)\n        if REPLS[abs_path]\n          REPLS[abs_path].call\n        elsif File.exist?(abs_path)\n          File.open(abs_path) do |file|\n            file.detect { file.lineno == lineno }\n          end\n        end\n      end\n    end\n  end\n\n  NameError.send(:attr, :frame_binding)\n  SPELL_CHECKERS['NoMethodError'] = Experimental::IvarNameCheckerBuilder.new(SPELL_CHECKERS['NoMethodError'])\nend\n",
    "did_you_mean/core_ext/name_error" => "module DidYouMean\n  module Correctable\n    def original_message\n      method(:to_s).super_method.call\n    end\n\n    def to_s\n      msg = super.dup\n\n      if !cause.respond_to?(:corrections) || cause.corrections.empty?\n        msg << DidYouMean.formatter.message_for(corrections)\n      end\n\n      msg\n    rescue\n      super\n    end\n\n    def corrections\n      @corrections ||= spell_checker.corrections\n    end\n\n    def spell_checker\n      SPELL_CHECKERS[self.class.to_s].new(self)\n    end\n  end\nend\n",
    "did_you_mean/levenshtein" => "module DidYouMean\n  module Levenshtein # :nodoc:\n    # This code is based directly on the Text gem implementation\n    # Copyright (c) 2006-2013 Paul Battley, Michael Neumann, Tim Fletcher.\n    #\n    # Returns a value representing the \"cost\" of transforming str1 into str2\n    def distance(str1, str2)\n      n = str1.length\n      m = str2.length\n      return m if n.zero?\n      return n if m.zero?\n\n      d = (0..m).to_a\n      x = nil\n\n      # to avoid duplicating an enumerable object, create it outside of the loop\n      str2_codepoints = str2.codepoints\n\n      str1.each_codepoint.with_index(1) do |char1, i|\n        j = 0\n        while j < m\n          cost = (char1 == str2_codepoints[j]) ? 0 : 1\n          x = min3(\n            d[j+1] + 1, # insertion\n            i + 1,      # deletion\n            d[j] + cost # substitution\n          )\n          d[j] = i\n          i = x\n\n          j += 1\n        end\n        d[m] = x\n      end\n\n      x\n    end\n    module_function :distance\n\n    private\n\n    # detects the minimum value out of three arguments. This method is\n    # faster than `[a, b, c].min` and puts less GC pressure.\n    # See https://github.com/yuki24/did_you_mean/pull/1 for a performance\n    # benchmark.\n    def min3(a, b, c)\n      if a < b && a < c\n        a\n      elsif b < c\n        b\n      else\n        c\n      end\n    end\n    module_function :min3\n  end\nend\n",
    "did_you_mean/spell_checker" => "# frozen-string-literal: true\n\nrequire \"did_you_mean/levenshtein\"\nrequire \"did_you_mean/jaro_winkler\"\n\nmodule DidYouMean\n  class SpellChecker\n    def initialize(dictionary: )\n      @dictionary = dictionary\n    end\n\n    def correct(input)\n      input     = normalize(input)\n      threshold = input.length > 3 ? 0.834 : 0.77\n\n      words = @dictionary.select {|word| JaroWinkler.distance(normalize(word), input) >= threshold }\n      words.reject! {|word| input == word.to_s }\n      words.sort_by! {|word| JaroWinkler.distance(word.to_s, input) }\n      words.reverse!\n\n      # Correct mistypes\n      threshold   = (input.length * 0.25).ceil\n      corrections = words.select {|c| Levenshtein.distance(normalize(c), input) <= threshold }\n\n      # Correct misspells\n      if corrections.empty?\n        corrections = words.select do |word|\n          word   = normalize(word)\n          length = input.length < word.length ? input.length : word.length\n\n          Levenshtein.distance(word, input) < length\n        end.first(1)\n      end\n\n      corrections\n    end\n\n    private\n\n    def normalize(str_or_symbol) #:nodoc:\n      str = if str_or_symbol.is_a?(String)\n              str_or_symbol.dup\n            else\n              str_or_symbol.to_s\n            end\n\n      str.downcase!\n      str.tr!(\"@\", \"\")\n      str\n    end\n  end\nend\n",
    "did_you_mean/formatters/plain_formatter" => "# frozen-string-literal: true\n\nmodule DidYouMean\n  # The +DidYouMean::PlainFormatter+ is the basic, default formatter for the\n  # gem. The formatter responds to the +message_for+ method and it returns a\n  # human readable string.\n  class PlainFormatter\n\n    # Returns a human readable string that contains +corrections+. This\n    # formatter is designed to be less verbose to not take too much screen\n    # space while being helpful enough to the user.\n    #\n    # @example\n    #\n    #   formatter = DidYouMean::PlainFormatter.new\n    #\n    #   # displays suggestions in two lines with the leading empty line\n    #   puts formatter.message_for([\"methods\", \"method\"])\n    #\n    #   Did you mean?  methods\n    #                   method\n    #   # => nil\n    #\n    #   # displays an empty line\n    #   puts formatter.message_for([])\n    #\n    #   # => nil\n    #\n    def message_for(corrections)\n      corrections.empty? ? \"\" : \"\\nDid you mean?  \#{corrections.join(\"\\n               \")}\"\n    end\n  end\nend\n",
    "did_you_mean/formatters/verbose_formatter" => "# frozen-string-literal: true\n\nmodule DidYouMean\n  # The +DidYouMean::VerboseFormatter+ uses extra empty lines to make the\n  # suggestion stand out more in the error message.\n  #\n  # In order to activate the verbose formatter,\n  #\n  # @example\n  #\n  #   OBject\n  #   # => NameError: uninitialized constant OBject\n  #   #    Did you mean?  Object\n  #\n  #   require 'did_you_mean/verbose'\n  #\n  #   OBject\n  #   # => NameError: uninitialized constant OBject\n  #   #\n  #   #        Did you mean? Object\n  #   #\n  #\n  class VerboseFormatter\n\n    # Returns a human readable string that contains +corrections+. This\n    # formatter is designed to be less verbose to not take too much screen\n    # space while being helpful enough to the user.\n    #\n    # @example\n    #\n    #   formatter = DidYouMean::PlainFormatter.new\n    #\n    #   puts formatter.message_for([\"methods\", \"method\"])\n    #\n    #\n    #       Did you mean? methods\n    #                     method\n    #\n    #   # => nil\n    #\n    def message_for(corrections)\n      return \"\" if corrections.empty?\n\n      output = \"\\n\\n    Did you mean? \".dup\n      output << corrections.join(\"\\n                  \")\n      output << \"\\n \"\n    end\n  end\nend\n",
    "did_you_mean/jaro_winkler" => "module DidYouMean\n  module Jaro\n    module_function\n\n    def distance(str1, str2)\n      str1, str2 = str2, str1 if str1.length > str2.length\n      length1, length2 = str1.length, str2.length\n\n      m          = 0.0\n      t          = 0.0\n      range      = (length2 / 2).floor - 1\n      range      = 0 if range < 0\n      flags1     = 0\n      flags2     = 0\n\n      # Avoid duplicating enumerable objects\n      str1_codepoints = str1.codepoints\n      str2_codepoints = str2.codepoints\n\n      i = 0\n      while i < length1\n        last = i + range\n        j    = (i >= range) ? i - range : 0\n\n        while j <= last\n          if flags2[j] == 0 && str1_codepoints[i] == str2_codepoints[j]\n            flags2 |= (1 << j)\n            flags1 |= (1 << i)\n            m += 1\n            break\n          end\n\n          j += 1\n        end\n\n        i += 1\n      end\n\n      k = i = 0\n      while i < length1\n        if flags1[i] != 0\n          j = index = k\n\n          k = while j < length2\n            index = j\n            break(j + 1) if flags2[j] != 0\n\n            j += 1\n          end\n\n          t += 1 if str1_codepoints[i] != str2_codepoints[index]\n        end\n\n        i += 1\n      end\n      t = (t / 2).floor\n\n      m == 0 ? 0 : (m / length1 + m / length2 + (m - t) / m) / 3\n    end\n  end\n\n  module JaroWinkler\n    WEIGHT    = 0.1\n    THRESHOLD = 0.7\n\n    module_function\n\n    def distance(str1, str2)\n      jaro_distance = Jaro.distance(str1, str2)\n\n      if jaro_distance > THRESHOLD\n        codepoints2  = str2.codepoints\n        prefix_bonus = 0\n\n        i = 0\n        str1.each_codepoint do |char1|\n          char1 == codepoints2[i] && i < 4 ? prefix_bonus += 1 : break\n          i += 1\n        end\n\n        jaro_distance + (prefix_bonus * WEIGHT * (1 - jaro_distance))\n      else\n        jaro_distance\n      end\n    end\n  end\nend\n",
    "did_you_mean/spell_checkers/key_error_checker" => "require \"did_you_mean/spell_checker\"\n\nmodule DidYouMean\n  class KeyErrorChecker\n    def initialize(key_error)\n      @key = key_error.key\n      @keys = key_error.receiver.keys\n    end\n\n    def corrections\n      @corrections ||= SpellChecker.new(dictionary: @keys).correct(@key).map(&:inspect)\n    end\n  end\nend\n",
    "did_you_mean/spell_checkers/method_name_checker" => "require \"did_you_mean/spell_checker\"\n\nmodule DidYouMean\n  class MethodNameChecker\n    attr_reader :method_name, :receiver\n\n    NAMES_TO_EXCLUDE = { NilClass => nil.methods }\n    NAMES_TO_EXCLUDE.default = []\n\n    # +MethodNameChecker::RB_RESERVED_WORDS+ is the list of reserved words in\n    # Ruby that take an argument. Unlike\n    # +VariableNameChecker::RB_RESERVED_WORDS+, those reserved words reqquires\n    # an argument, and a +NoMethodError+ is raised due to the presence of the\n    # argument.\n    #\n    # The +MethodNameChecker+ will use this list to suggest a reversed word if\n    # a +NoMethodError+ is raised and found closest matches.\n    #\n    # Also see +VariableNameChecker::RB_RESERVED_WORDS+.\n    RB_RESERVED_WORDS = %i(\n      alias\n      case\n      def\n      defined?\n      elsif\n      end\n      ensure\n      for\n      rescue\n      super\n      undef\n      unless\n      until\n      when\n      while\n      yield\n    )\n\n    def initialize(exception)\n      @method_name  = exception.name\n      @receiver     = exception.receiver\n      @private_call = exception.respond_to?(:private_call?) ? exception.private_call? : false\n    end\n\n    def corrections\n      @corrections ||= SpellChecker.new(dictionary: RB_RESERVED_WORDS + method_names).correct(method_name) - NAMES_TO_EXCLUDE[@receiver.class]\n    end\n\n    def method_names\n      method_names = receiver.methods + receiver.singleton_methods\n      method_names += receiver.private_methods if @private_call\n      method_names.uniq!\n      method_names\n    end\n  end\nend\n",
    "did_you_mean/spell_checkers/name_error_checkers" => "require 'did_you_mean/spell_checkers/name_error_checkers/class_name_checker'\nrequire 'did_you_mean/spell_checkers/name_error_checkers/variable_name_checker'\n\nmodule DidYouMean\n  class << (NameErrorCheckers = Object.new)\n    def new(exception)\n      case exception.original_message\n      when /uninitialized constant/\n        ClassNameChecker\n      when /undefined local variable or method/,\n           /undefined method/,\n           /uninitialized class variable/,\n           /no member '.*' in struct/\n        VariableNameChecker\n      else\n        NullChecker\n      end.new(exception)\n    end\n  end\nend\n",
    "did_you_mean/spell_checkers/name_error_checkers/class_name_checker" => "# frozen-string-literal: true\nrequire 'delegate'\nrequire \"did_you_mean/spell_checker\"\n\nmodule DidYouMean\n  class ClassNameChecker\n    attr_reader :class_name\n\n    def initialize(exception)\n      @class_name, @receiver, @original_message = exception.name, exception.receiver, exception.original_message\n    end\n\n    def corrections\n      @corrections ||= SpellChecker.new(dictionary: class_names)\n                         .correct(class_name)\n                         .map(&:full_name)\n                         .reject {|qualified_name| @original_message.include?(qualified_name) }\n    end\n\n    def class_names\n      scopes.flat_map do |scope|\n        scope.constants.map do |c|\n          ClassName.new(c, scope == Object ? \"\" : \"\#{scope}::\")\n        end\n      end\n    end\n\n    def scopes\n      @scopes ||= @receiver.to_s.split(\"::\").inject([Object]) do |_scopes, scope|\n        _scopes << _scopes.last.const_get(scope)\n      end.uniq\n    end\n\n    class ClassName < SimpleDelegator\n      attr :namespace\n\n      def initialize(name, namespace = '')\n        super(name)\n        @namespace = namespace\n      end\n\n      def full_name\n        self.class.new(\"\#{namespace}\#{__getobj__}\")\n      end\n    end\n\n    private_constant :ClassName\n  end\nend\n",
    "did_you_mean/spell_checkers/name_error_checkers/variable_name_checker" => "# frozen-string-literal: true\n\nrequire \"did_you_mean/spell_checker\"\n\nmodule DidYouMean\n  class VariableNameChecker\n    attr_reader :name, :method_names, :lvar_names, :ivar_names, :cvar_names\n\n    NAMES_TO_EXCLUDE = { 'foo' => [:fork, :for] }\n    NAMES_TO_EXCLUDE.default = []\n\n    # +VariableNameChecker::RB_RESERVED_WORDS+ is the list of all reserved\n    # words in Ruby. They could be declared like methods are, and a typo would\n    # cause Ruby to raise a +NameError+ because of the way they are declared.\n    #\n    # The +:VariableNameChecker+ will use this list to suggest a reversed word\n    # if a +NameError+ is raised and found closest matches, excluding:\n    #\n    #   * +do+\n    #   * +if+\n    #   * +in+\n    #   * +or+\n    #\n    # Also see +MethodNameChecker::RB_RESERVED_WORDS+.\n    RB_RESERVED_WORDS = %i(\n      BEGIN\n      END\n      alias\n      and\n      begin\n      break\n      case\n      class\n      def\n      defined?\n      else\n      elsif\n      end\n      ensure\n      false\n      for\n      module\n      next\n      nil\n      not\n      redo\n      rescue\n      retry\n      return\n      self\n      super\n      then\n      true\n      undef\n      unless\n      until\n      when\n      while\n      yield\n      __LINE__\n      __FILE__\n      __ENCODING__\n    )\n\n    def initialize(exception)\n      @name       = exception.name.to_s.tr(\"@\", \"\")\n      @lvar_names = exception.respond_to?(:local_variables) ? exception.local_variables : []\n      receiver    = exception.receiver\n\n      @method_names = receiver.methods + receiver.private_methods\n      @ivar_names   = receiver.instance_variables\n      @cvar_names   = receiver.class.class_variables\n      @cvar_names  += receiver.class_variables if receiver.kind_of?(Module)\n    end\n\n    def corrections\n      @corrections ||= SpellChecker\n                     .new(dictionary: (RB_RESERVED_WORDS + lvar_names + method_names + ivar_names + cvar_names))\n                     .correct(name) - NAMES_TO_EXCLUDE[@name]\n    end\n  end\nend\n",
    "did_you_mean/spell_checkers/null_checker" => "module DidYouMean\n  class NullChecker\n    def initialize(*);  end\n    def corrections; [] end\n  end\nend\n",
    "did_you_mean/experimental" => "require 'did_you_mean/experimental/initializer_name_correction'\nrequire 'did_you_mean/experimental/ivar_name_correction'\n",
    "did_you_mean/version" => "module DidYouMean\n  VERSION = \"1.3.0\"\nend\n",
    "did_you_mean/verbose" => "require 'did_you_mean'\nrequire 'did_you_mean/formatters/verbose_formatter'\n\nDidYouMean.formatter = DidYouMean::VerboseFormatter.new\n",
    "did_you_mean" => "require \"did_you_mean/version\"\nrequire \"did_you_mean/core_ext/name_error\"\n\nrequire \"did_you_mean/spell_checker\"\nrequire 'did_you_mean/spell_checkers/name_error_checkers'\nrequire 'did_you_mean/spell_checkers/method_name_checker'\nrequire 'did_you_mean/spell_checkers/key_error_checker'\nrequire 'did_you_mean/spell_checkers/null_checker'\n\nrequire \"did_you_mean/formatters/plain_formatter\"\n\n# The +DidYouMean+ gem adds functionality to suggest possible method/class\n# names upon errors such as +NameError+ and +NoMethodError+. In Ruby 2.3 or\n# later, it is automatically activated during startup.\n#\n# @example\n#\n#   methosd\n#   # => NameError: undefined local variable or method `methosd' for main:Object\n#   #   Did you mean?  methods\n#   #                  method\n#\n#   OBject\n#   # => NameError: uninitialized constant OBject\n#   #    Did you mean?  Object\n#\n#   @full_name = \"Yuki Nishijima\"\n#   first_name, last_name = full_name.split(\" \")\n#   # => NameError: undefined local variable or method `full_name' for main:Object\n#   #    Did you mean?  @full_name\n#\n#   @@full_name = \"Yuki Nishijima\"\n#   @@full_anme\n#   # => NameError: uninitialized class variable @@full_anme in Object\n#   #    Did you mean?  @@full_name\n#\n#   full_name = \"Yuki Nishijima\"\n#   full_name.starts_with?(\"Y\")\n#   # => NoMethodError: undefined method `starts_with?' for \"Yuki Nishijima\":String\n#   #    Did you mean?  start_with?\n#\n#   hash = {foo: 1, bar: 2, baz: 3}\n#   hash.fetch(:fooo)\n#   # => KeyError: key not found: :fooo\n#   #    Did you mean?  :foo\n#\n#\n# == Disabling +did_you_mean+\n#\n# Occasionally, you may want to disable the +did_you_mean+ gem for e.g.\n# debugging issues in the error object itself. You can disable it entirely by\n# specifying +--disable-did_you_mean+ option to the +ruby+ command:\n#\n#   $ ruby --disable-did_you_mean -e \"1.zeor?\"\n#   -e:1:in `<main>': undefined method `zeor?' for 1:Integer (NameError)\n#\n# When you do not have direct access to the +ruby+ command (e.g.\n# +rails console+, +irb+), you could applyoptions using the +RUBYOPT+\n# environment variable:\n#\n#   $ RUBYOPT='--disable-did_you_mean' irb\n#   irb:0> 1.zeor?\n#   # => NoMethodError (undefined method `zeor?' for 1:Integer)\n#\n#\n# == Getting the original error message\n#\n# Sometimes, you do not want to disable the gem entirely, but need to get the\n# original error message without suggestions (e.g. testing). In this case, you\n# could use the +#original_message+ method on the error object:\n#\n#   no_method_error = begin\n#                       1.zeor?\n#                     rescue NoMethodError => error\n#                       error\n#                     end\n#\n#   no_method_error.message\n#   # => NoMethodError (undefined method `zeor?' for 1:Integer)\n#   #    Did you mean?  zero?\n#\n#   no_method_error.original_message\n#   # => NoMethodError (undefined method `zeor?' for 1:Integer)\n#\nmodule DidYouMean\n  # Map of error types and spell checker objects.\n  SPELL_CHECKERS = Hash.new(NullChecker)\n\n  SPELL_CHECKERS.merge!({\n    \"NameError\"     => NameErrorCheckers,\n    \"NoMethodError\" => MethodNameChecker,\n    \"KeyError\"      => KeyErrorChecker\n  })\n\n  NameError.prepend DidYouMean::Correctable\n  KeyError.prepend DidYouMean::Correctable\n\n  # Returns the currenctly set formatter. By default, it is set to +DidYouMean::Formatter+.\n  def self.formatter\n    @@formatter\n  end\n\n  # Updates the primary formatter used to format the suggestions.\n  def self.formatter=(formatter)\n    @@formatter = formatter\n  end\n\n  self.formatter = PlainFormatter.new\nend\n"
  }
end
eval(Rubinjam::LIBRARIES.fetch("rubinjam/internal"), TOPLEVEL_BINDING, "rubinjam")
#!/usr/bin/env ruby
require 'optparse'

$LOAD_PATH << File.join(File.dirname(__FILE__), '..', 'lib')
require 'rubinjam'

OptionParser.new do |opts|
  opts.banner = <<BANNER
Rubinjam

Jam a gem into a universal binary that works with any ruby

Usage:
    rubinjam # convert current directory into a binary

Options:
BANNER
  opts.on("-h", "--help","Show this.") { puts opts; exit }
  opts.on('-v', '--version','Show Version'){ require 'rubinjam/version'; puts Rubinjam::VERSION; exit}
end.parse!

Rubinjam.write(Dir.pwd)
